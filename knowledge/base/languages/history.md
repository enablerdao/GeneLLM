# History of Programming Languages

This document traces the evolution of programming languages from the earliest computing concepts to modern developments.

## Pre-Electronic Computing Era (Before 1940s)

### Theoretical Foundations

- **1843**: Ada Lovelace writes the first algorithm intended for implementation on Charles Babbage's Analytical Engine, making her the first programmer.
- **1847-1854**: George Boole develops Boolean algebra, which becomes fundamental to computer science.
- **1936**: Alan Turing introduces the concept of a universal computing machine (Turing machine).
- **1937**: Claude Shannon shows how Boolean algebra can be used to design digital circuits.

### Early Mechanical Programming

- **Jacquard Loom (1804)**: Uses punched cards to control weaving patterns, an early form of programming.
- **Analytical Engine**: Designed by Charles Babbage with a "store" (memory) and "mill" (processor), and programmed with punched cards.

## First Generation: Machine Code (1940s)

- **Binary Machine Code**: The first electronic computers like ENIAC (1945) were programmed by physically rewiring the machine.
- **Stored Program Concept**: EDSAC and EDVAC implement the stored program concept where instructions are stored in memory.

## Second Generation: Assembly Languages (Late 1940s-1950s)

- **Assembly Language**: Symbolic representation of machine code, with mnemonics representing operations.
- **1947**: Betty Holberton develops the first sort-merge generator, considered by some to be the first software.
- **1949**: Short Code (or Brief Code), one of the first higher-level languages, developed for the BINAC computer.

## Third Generation: High-Level Languages (1950s-1970s)

### 1950s: The Birth of High-Level Languages

- **1952-1954**: Autocode, developed by Alick Glennie, considered the first compiled programming language.
- **1957**: FORTRAN (FORmula TRANslation), developed by John Backus at IBM, the first widely used high-level language.
- **1958**: LISP (LISt Processor), created by John McCarthy, the second-oldest high-level language still in common use.
- **1958-1959**: ALGOL (ALGOrithmic Language), influential in language design and the ancestor of many languages.
- **1959**: COBOL (COmmon Business-Oriented Language), designed by Grace Hopper and others for business data processing.

### 1960s: Diversification

- **1964**: BASIC (Beginner's All-purpose Symbolic Instruction Code), designed by John Kemeny and Thomas Kurtz to be accessible to non-science students.
- **1964**: PL/I (Programming Language One), designed by IBM as a universal language.
- **1967**: SIMULA, by Ole-Johan Dahl and Kristen Nygaard, introduces the concept of objects and classes.
- **1968**: Logo, by Seymour Papert, designed for educational use.
- **1969**: B, by Ken Thompson and Dennis Ritchie, a simplified version of BCPL and the immediate predecessor to C.

### 1970s: Structured Programming and Beyond

- **1970**: Pascal, by Niklaus Wirth, designed to encourage structured programming.
- **1972**: C, by Dennis Ritchie at Bell Labs, combining high-level functionality with low-level access to memory.
- **1972**: Smalltalk, by Alan Kay, Adele Goldberg, and others at Xerox PARC, the first fully object-oriented language.
- **1972**: Prolog, by Alain Colmerauer, a logic programming language.
- **1975**: Scheme, by Guy Steele and Gerald Sussman, a dialect of Lisp.
- **1978**: SQL (Structured Query Language), developed at IBM for database management.

## Fourth Generation: Object-Oriented and Specialized Languages (1980s-1990s)

### 1980s: Object-Oriented Programming Takes Hold

- **1980**: Ada, named after Ada Lovelace, developed for the U.S. Department of Defense.
- **1983**: C++, by Bjarne Stroustrup, adding object-oriented features to C.
- **1983**: Objective-C, by Brad Cox, another object-oriented extension of C.
- **1984**: Common Lisp, a standardized version of Lisp.
- **1987**: Perl, by Larry Wall, designed for text processing.
- **1989**: FL (Function Level), by John Backus, a functional programming language.

### 1990s: The Internet Age

- **1990**: Haskell, a standardized purely functional language.
- **1991**: Python, by Guido van Rossum, emphasizing code readability.
- **1991**: Visual Basic, by Microsoft, for rapid application development.
- **1993**: Ruby, by Yukihiro Matsumoto, combining features from Perl, Smalltalk, and other languages.
- **1995**: Java, by James Gosling at Sun Microsystems, designed for "write once, run anywhere" portability.
- **1995**: JavaScript (initially called Mocha, then LiveScript), by Brendan Eich at Netscape, for web programming.
- **1995**: PHP, by Rasmus Lerdorf, for server-side web development.
- **1998**: C#, by Microsoft, as part of the .NET initiative.

## Fifth Generation: Modern Languages (2000s-Present)

### 2000s: Web and Multiparadigm Languages

- **2000**: ActionScript, for Adobe Flash applications.
- **2003**: Scala, combining object-oriented and functional programming.
- **2003**: Groovy, an object-oriented language for the Java platform.
- **2005**: F#, a functional-first language for the .NET platform.
- **2007**: Clojure, a modern Lisp dialect targeting the JVM.
- **2009**: Go (Golang), by Google, designed for simplicity and efficiency in concurrent systems.

### 2010s: Safety, Performance, and Accessibility

- **2010**: Rust, by Mozilla, focusing on safety and performance.
- **2011**: Kotlin, a modern language targeting the JVM and Android.
- **2012**: TypeScript, by Microsoft, adding static typing to JavaScript.
- **2012**: Elixir, built on the Erlang VM, for scalable and maintainable applications.
- **2014**: Swift, by Apple, for iOS and macOS development.
- **2016**: Julia, for high-performance numerical analysis and computational science.
- **2019**: Dart 2.0, by Google, for building mobile, desktop, and web applications.

## Language Paradigm Evolution

### Imperative Programming

- Focuses on describing how a program operates step by step
- Early examples: FORTRAN, ALGOL, COBOL
- Modern examples: C, Go

### Procedural Programming

- An imperative style organizing code into procedures/subroutines
- Examples: C, Pascal, BASIC

### Object-Oriented Programming

- Organizes code around "objects" containing data and methods
- Early examples: Simula, Smalltalk
- Mainstream adoption: C++, Java, C#, Python

### Functional Programming

- Treats computation as the evaluation of mathematical functions
- Early examples: LISP, ML
- Modern examples: Haskell, Clojure, F#, Scala

### Logic Programming

- Based on formal logic, programs express facts and rules
- Examples: Prolog, Mercury

### Concurrent Programming

- Focuses on executing multiple tasks simultaneously
- Examples: Erlang, Go, Rust

### Reactive Programming

- Focuses on data flows and propagation of changes
- Examples: Reactive extensions in various languages

## Influential Language Features and Their Origins

- **Garbage Collection**: LISP (1958)
- **Object-Oriented Programming**: Simula (1967)
- **Generic Programming**: Ada (1980), C++ Templates (1991)
- **Exception Handling**: PL/I (1964), popularized by Ada and C++
- **Lambda Expressions**: LISP (1958), now in many languages
- **Pattern Matching**: SNOBOL (1962), now in many functional languages
- **Type Inference**: ML (1973), now in languages like Haskell, Rust, Swift
- **Async/Await**: C# (2012), now in JavaScript, Python, Rust
- **Ownership Model**: Rust (2010)

## Language Design Influences

Many languages have influenced the design of others:

- **ALGOL** → Pascal, C
- **C** → C++, C#, Java, JavaScript, Go, Rust
- **Smalltalk** → Ruby, Objective-C, Swift
- **LISP** → Scheme, Common Lisp, Clojure
- **ML** → Haskell, OCaml, F#, Rust
- **Java** → C#, Kotlin, Scala
- **JavaScript** → TypeScript, CoffeeScript

## Future Trends

- **WebAssembly**: Allowing multiple languages to run in browsers
- **Gradual Typing**: Adding optional type systems to dynamic languages
- **Dependent Types**: Types that depend on values, for more precise specifications
- **Effect Systems**: Tracking and controlling side effects
- **Language-Integrated Query**: SQL-like capabilities within programming languages
- **Low-Code/No-Code**: Visual programming environments
- **AI-Assisted Programming**: Tools like GitHub Copilot
- **Quantum Computing Languages**: Q#, Silq, Qiskit